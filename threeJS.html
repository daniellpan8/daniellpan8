<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8">
  	<title>Pan's Bedroom?</title>
  	<style>
    	
    	body { 
    		margin: 0; 
    		overflow: hidden;
    		display: flex;
  			justify-content: center;
  			align-items: center;
    	}
    	canvas { width: 100%; height: 100%; }
    	#button1 {
    		position: absolute;
    		color: #0000ff;
    		top: 2rem;
    	}
    	.crosshair {
    	  position: fixed;
    	  width: 3px;
    	  height: 20px;
    	  border: 1.5px solid red;
    	  
    	}
    	.crosshair2 {
    	  position: fixed;
    	  width: 20px;
    	  height: 3px;
    	  border: 1.5px solid red;
    	  
    	}
    	
		@media only screen and (max-width: 1000px) {
			canvas {
				height: 100%;
			}
			#button1 {
				display: none;
			}
			.crosshair {
				display: none;
			}
			.crosshair2 {
				display: none;
			}
		}
  	</style>
</head>
<body>
	<button id="button1">CLICK FOR FIRST PERSON VIEW</button>
	<div class = "crosshair"></div>
	<div class = "crosshair2"></div>

  	<script type="module">

	    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
	    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
	    import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/RGBELoader.js';
	    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';
	    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/PointerLockControls.js';


	    //init();
	    
	    //renderer
    	const renderer = new THREE.WebGLRenderer();
	    renderer.setSize(window.innerWidth, window.innerHeight);
	    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    	renderer.toneMappingExposure = 1.0;
    	renderer.shadowMap.enabled = true;
    	renderer.shadowMap.type = THREE.BasicShadowMap;
    	document.body.appendChild(renderer.domElement);
	    
	    //scene
	    const scene = new THREE.Scene();
	    scene.background = new THREE.Color(0x87ceeb);

	    //camera
	    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
	    camera.position.set(3, 10, 3);

	    

	    	
	    
	    

	    //renderer.domElement.addEventListener('mousemove', onMouseMove);
//renderer.domElement.addEventListener('mouseleave', onMouseLeave);
/*
	    const textureLoader = new THREE.TextureLoader();
		const texture = textureLoader.load('https://cdn.polyhaven.com/asset_img/primary/christmas_photo_studio_06.png?height=780', function(texture) {
			texture.mapping = THREE.EquirectangularReflectionMapping;
			texture.encoding = THREE.sRGBEncoding;
		});

		scene.background = texture;
		scene.environment = texture;

*/

/*
		const textureLoader = new THREE.TextureLoader();
		//const texture = textureLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/workshop.jpg');
		//const texture = textureLoader.load('https://cdn.polyhaven.com/asset_img/primary/christmas_photo_studio_06.png?height=780');
		const texture = textureLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/sunflowers_puresky.jpg');

		texture.mapping = THREE.EquirectangularReflectionMapping;
		texture.encoding = THREE.sRGBEncoding;
		texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
		texture.wrapS = THREE.RepeatWrapping;
		texture.repeat.set(2, 1);
		scene.background = texture;
		scene.environment = texture;
*/

	    

	    

	    //orbit controls
	    /*
	    const controls = new OrbitControls(camera, renderer.domElement);
	    controls.target.set(0, 10, 0);
	    controls.autoRotate = true;
	    controls.autoRotateSpeed = 0.5;
	    controls.enableDamping = true;
	    */
	    //controls.maxDistance = 11;

	    //controls.enablePan = false;

	    


	    
	    //detects if mobile
	    function isMobileDevice() {
    		return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
		}

		//controls
	    let controls;
	    if (isMobileDevice()) {
	    	controls = new OrbitControls(camera, renderer.domElement);
	    	controls.target.set(0, 10, 0);
		    controls.autoRotate = true;
		    controls.autoRotateSpeed = 0.5;
		    controls.enableDamping = true;
	    } else {
	    	controls = new PointerLockControls(camera, renderer.domElement);
	    	controls.pointerSpeed = 1;
	    	camera.lookAt(0, 9.5, 0);
	    	//controls.movementSpeed = 5;
	    }

	    //click button for fps
	    let clock = new THREE.Clock();
	    const button = document.querySelector('#button1');
	    button.addEventListener('click', function() {
	    	if (!isMobileDevice()) {
	    		controls.lock();

	    	}
	    });

	    const keyboard = [];
	    var playerY = camera.position.y;
	    //let jumping = false;
	    //tracks which keys are pressed
	    addEventListener('keydown', (e)=>{
	    	keyboard[e.key] = true;
	    });
	    addEventListener('keyup', (e)=>{
    if (e.key === 'e' ) {
        keyboard['e'] = false;
    } else {
        keyboard[e.key] = false;
    }
});

	    var jumpClock = 0;
	    let speed = 6;
	    function processKeyboard(delta) {
	    	
	    	var actualSpeed = speed * delta;
	    	if (keyboard['w']){
	    		controls.moveForward(actualSpeed);
	    	}
	    	if (keyboard['s']){
	    		controls.moveForward(-actualSpeed);
	    	}
	    	if (keyboard['d']){
	    		controls.moveRight(actualSpeed);
	    	}
	    	if (keyboard['a']){
	    		controls.moveRight(-actualSpeed);
	    	}
	    	if (keyboard[' ']){
		        camera.position.y += 0.1;
		    }
		    if (keyboard['Shift']){
		    	camera.position.y -= 0.1;
		    }
		    if (keyboard['e']){
		        speed = 10;
		    } else {
		        speed = 6;
		    }
	    }

	    //room loader
	    const loader = new GLTFLoader();
		loader.load('myRoom.glb', function(gltf) {
    		const object = gltf.scene;
    		object.scale.set(5,5,5);
    		object.traverse((node) => {
        		if (node.isMesh) {
            		node.castShadow = true;
            		node.receiveShadow = true;
        		}
    		});
    		scene.add(object);
		}, undefined, function(error) {
    		console.error(error);
		});

		//face loader
		loader.load('faceScan2.glb', function(g) {
			const face = g.scene;
    		face.scale.set(30,30,30);
    		face.position.set(0, 8, -14);
    		face.rotation.y = Math.PI;
    		face.traverse((node) => {
        		if (node.isMesh) {
            		node.castShadow = true;
            		node.receiveShadow = true;
        		}
    		});
    		scene.add(face);
/*
    		const update = () => {
	    		const camVec = camera.position.clone().sub(face.position);

	    		const angle = Math.atan2(camVec.x, camVec.z);

	    		face.rotation.y = angle;

	    		requestAnimationFrame(update);
  			};
  			update();
  			*/
		}, undefined, function(error) {
    		console.error(error);
		});

		//about
		loader.load('about.glb', function(gltf2) {
    		const about = gltf2.scene;
    		about.scale.set(0.25,0.25,0.25);
    		about.traverse((node) => {
        		if (node.isMesh) {
            		node.castShadow = true;
            		node.receiveShadow = true;
        		}
    		});
    		scene.add(about);
    		about.position.set(0, 10, 0);
    		const update = () => {
	    		const camVec = camera.position.clone().sub(about.position);

	    		const angle = Math.atan2(camVec.x, camVec.z);

	    		about.rotation.y = angle;

	    		requestAnimationFrame(update);
  			};
  			update();
		}, undefined, function(error) {
    		console.error(error);
		});

		//ambientLight
	    const light3 = new THREE.AmbientLight(0x404040);
		scene.add(light3);

	    //point light
	    const light4 = new THREE.PointLight(0xffffff, 1, 100);
	    light4.position.set(0, 20, 0);
	    light4.castShadow = true;
	    light4.shadow.mapSize.width = 2048;
		light4.shadow.mapSize.height = 2048;
		light4.shadow.bias = -0.0005;
	    scene.add(light4);

	    //light sphere
	    var lightGeometry = new THREE.SphereGeometry(0.1, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
		const lightMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff} );
		var lightSphere = new THREE.Mesh(lightGeometry, lightMaterial);
		lightSphere.position.set(0, 30, 0);
	    scene.add(lightSphere);
/*
	    const lightSphereClone = [];
	    for (let i = 0; i < 5; i++){
	    	//const lightSphereClone[] = lightSphere.clone();
	    	lightSphereClone[i] = lightSphere.clone();
		lightSphereClone[i].position.set(1+i, 9.9 , 0);
		lightSphereClone[i].castShadow = true;
		scene.add(lightSphereClone[i]);
	    }
	    
		
*/
	    //middle sphere
	    var sphereGeometry = new THREE.SphereGeometry(0.1, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
	    var sphere = new THREE.Mesh(sphereGeometry, lightMaterial);
	    sphere.position.set(0,9.9,0);
	    sphere.castShadow = true;
	    sphere.addEventListener('click', function() {
	    	console.log('Sphere clicked!');
  			window.location.href = 'index.html';
		});
	    scene.add(sphere);
	    //sphere.name = 'sphere';

		renderer.domElement.addEventListener('mousedown', onDocumentMouseDown);

		function onDocumentMouseDown(event) {
		// Only respond to left mouse button clicks
			if (event.button !== 0) return;

			// Create a raycaster object
			const raycaster = new THREE.Raycaster();

			// Set the raycaster's origin to the center of the screen
			const screenCenter = new THREE.Vector2(0, 0);
			//screenCenter.add(crosshairPos);
			raycaster.setFromCamera(screenCenter, camera);

			// Check for intersections with the sphere
			const intersectSphere = raycaster.intersectObject(sphere);
			const intersectObj = raycaster.intersectObject(lightSphere);

			// If the ray intersects with the sphere, redirect to another page
			if (intersectSphere.length > 0) {
				window.location.href = 'index.html';
			}
			if (intersectObj.length > 0) {
				window.location.href = 'https://google.com';
			}
		}

	    //plane?
	    //const pGeometry = new THREE.BoxGeometry(500, 1, 500);
	    const pGeometry = new THREE.CylinderGeometry(500, 500, 1, 20)
		const pMaterial = new THREE.MeshStandardMaterial({color: 0x00ff00});
		const plane = new THREE.Mesh(pGeometry, pMaterial);
		plane.position.set(0, -0.8, 0);
		plane.receiveShadow = true;
		scene.add(plane);

		/*

		//cube?
		const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);

// Create a material for the cube
		const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

	// Create a mesh object that combines the geometry and material
		const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);

	// Add the mesh object to the scene
		scene.add(cubeMesh);
		cubeMesh.position.set(10,10,0);

		const update = () => {
    // Calculate the vector between the camera and the model
    const camVec = camera.position.clone().sub(cubeMesh.position);

    // Calculate the angle between the camera vector and the model's forward vector
    const angle = Math.atan2(camVec.x, camVec.z);

    // Rotate the model around the Y-axis to face the camera
    cubeMesh.rotation.y = angle;

    // Request the next frame update
    requestAnimationFrame(update);
  };

  // Start the update loop
  update();
		
*/
		//gridHelper
	    const gridHelper = new THREE.GridHelper(60, 60, 0xfc03d7, 0xffff00);

		gridHelper.material.opacity = 0.5;
		gridHelper.material.transparent = true;
		const lines = gridHelper.children.filter(child => child instanceof THREE.LineSegments);

// Set the color of every 5th line to red
lines.forEach((line, index) => {
  if (index % 5 === 0) {
    line.material.color.set(0xff0000);
  }
});
		scene.add(gridHelper);

		const gridHelper2 = gridHelper.clone();
		gridHelper2.rotation.z = Math.PI/2;
		scene.add(gridHelper2);

		const gridHelper3 = gridHelper.clone();
		gridHelper3.rotation.x = Math.PI/2;
		scene.add(gridHelper3);
		
	    //animatiion / render
	    function animate() {
	    	requestAnimationFrame(animate);

	    	const delta = clock.getDelta();

	    	processKeyboard(delta);
	   
		    if (isMobileDevice()) {
	    		controls.update();
	    	}

	    	//about.rotation.y += 0.1;

		    renderer.render(scene, camera);
		}
		
	    animate();

  	</script>

</body>
</html>
