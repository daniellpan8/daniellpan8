<!DOCTYPE html>
<html>
<head>
  	<meta charset="utf-8">
  	<title>Three.js Example</title>
  	<style>
    	body { margin: 0; }
    	canvas { width: 100%; height: 100%; }
    	
  

@media only screen and (min-width: 600px) {
  canvas {
    height: 100%;
  }
}
  	</style>
</head>
<body>

  	<script type="module">

	    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
	    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
	    import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/RGBELoader.js';

	    const renderer = new THREE.WebGLRenderer();
	    renderer.setSize(window.innerWidth, window.innerHeight);
	    
	    const stew = {
  			hdr: 'stew.hdr'
		};

	    const scene = new THREE.Scene();

	    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
	    camera.position.set(0, 20, 100);
	    camera.position.set(50, 30, 50);

	    //renderer.domElement.addEventListener('mousemove', onMouseMove);
//renderer.domElement.addEventListener('mouseleave', onMouseLeave);
/*
	    const textureLoader = new THREE.TextureLoader();
		const texture = textureLoader.load('https://cdn.polyhaven.com/asset_img/primary/christmas_photo_studio_06.png?height=780', function(texture) {
			texture.mapping = THREE.EquirectangularReflectionMapping;
			texture.encoding = THREE.sRGBEncoding;
		});

		scene.background = texture;
		scene.environment = texture;

*/

		const textureLoader = new THREE.TextureLoader();
		const texture = textureLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/workshop.jpg');
		texture.mapping = THREE.EquirectangularReflectionMapping;
		texture.encoding = THREE.sRGBEncoding;
		texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
		texture.wrapS = THREE.RepeatWrapping;
		texture.repeat.set(2, 1);
		scene.background = texture;
		scene.environment = texture;
		//renderer.setSize(2048, 1024);
/*
	    new RGBELoader().load("https://happy358.github.io/Images/HDR/rathaus_2k.jpg", function(texture) {
	    	texture.mapping = THREE.EquirectangularReflectionMapping;
	    	scene.background = texture;
	    	scene.environment = texture;
	    }); 


	    function ( xhr ) {
  console.log( 'HDR loading progress:', ( xhr.loaded / xhr.total * 100 ) + '%');
}, function ( error ) {
  console.error( 'An error occurred while loading the HDR file:', error );
});
*/
	    

	    renderer.toneMapping = THREE.ACESFilmicToneMapping;
	    renderer.toneMappingExposure = 1.0;

	    document.body.appendChild(renderer.domElement);

	    //orbit controls
	    const controls = new OrbitControls(camera, renderer.domElement);
	    controls.autoRotate = true;
	    controls.autoRotateSpeed = 0.5;
	    controls.enableDamping = true;
	    controls.enablePan = false;

	    //torus
	    /*
	    const geometry = new THREE.TorusGeometry(10, 3, 16, 100);
	    const material = new THREE.MeshPhongMaterial({color: 0xfc03d7});
	    const torus = new THREE.Mesh(geometry, material);
	    scene.add(torus);
	    

	    //torusKnot
	    const torusKnotGeometry = new THREE.TorusKnotGeometry(10, 1.3, 300, 20, 8, 7);
	    const material = new THREE.MeshPhongMaterial({color: 0xfc03d7});
		const torusKnot = new THREE.Mesh(torusKnotGeometry, material);
		scene.add(torusKnot);

		*/

		/*
		var geo = new THREE.PlaneBufferGeometry(2000, 2000, 8, 8);
		var mat = new THREE.MeshPhongMaterial({ color: 0x404040, side: THREE.SingleSide });
		var plane = new THREE.Mesh(geo, mat);
		plane.rotation.x = Math.PI/2;
		plane.rotation.y = Math.PI;

		scene.add(plane);
		plane.position.set(0,-10,0);

		*/

	    //directionalLight
	    const light = new THREE.PointLight(0xffffff, 0.5, 100);
	    light.position.set(15, 0, 15);
	    scene.add(light);

	    const light2 = new THREE.PointLight(0xffffff, 0.5, 100);
	    light2.position.set(-15, 0, -15);
	    scene.add(light2);

	    const light4 = new THREE.PointLight(0xffffff, 1, 200);
	    light4.position.set(0, 50, 0);
	    scene.add(light4);

	    //ambientLight
	    const light3 = new THREE.AmbientLight(0x404040);
		scene.add(light3);

		//directional light source
		var lightGeometry = new THREE.SphereGeometry(2, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
		const lightMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
		var lightSphere = new THREE.Mesh(lightGeometry, lightMaterial);
		lightSphere.position.set(0, 50, 0);
	    scene.add(lightSphere);


	    //sphere
	    var geometry2 = new THREE.SphereGeometry(2, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
		const material2 = new THREE.MeshBasicMaterial( { color: 0xffff00, transparent: true, opacity: 0.5} );
		var sphere = new THREE.Mesh(geometry2, material2);
		sphere.position.set(15,0,15);

		//var geometry6 = new THREE.SphereGeometry(2, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
		var sphere2 = new THREE.Mesh(geometry2, material2);
		sphere2.position.set(-15,0,-15);


		//sphereAxis
		var geometry3 = new THREE.TorusGeometry(21.3, 0.5, 10, 100);
		const material3 = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true, transparent: true, opacity: 0.1});
	    const sphereAxis = new THREE.Mesh(geometry3, material3);
	    scene.add(sphereAxis);
	    sphereAxis.rotation.x = Math.PI/2;

	    
	    //sphereAxis2
	    const sphereAxis2 = new THREE.Mesh(geometry3, material3);
	    scene.add(sphereAxis2);
	    sphereAxis2.rotation.x = Math.PI/2;
	    sphereAxis2.position.set(0, 15, 0);

	    /*
	    //sphereAxis2
	    var geometry5 = new THREE.TorusGeometry(40, 0.5, 10, 100);
	    const sphereAxis3 = new THREE.Mesh(geometry5, material3);
	    scene.add(sphereAxis3);
	    sphereAxis3.rotation.x = Math.PI/2;
		*/
		
		//gridHelper
	    const gridHelper = new THREE.GridHelper(200, 50, 0xfc03d7, 0xffff00);
		gridHelper.material.opacity = 0.5;
		gridHelper.material.transparent = true;
		scene.add(gridHelper);
		//gridHelper.rotation.x = Math.PI/2;
		//gridHelper.rotation.y = Math.PI/1;
		
		//pivot
		var pivot = new THREE.Object3D();
		//add sphere and light
		pivot.add(sphere);
		pivot.add(light);
		scene.add(pivot);
		pivot.position.set(0, 0, 0);
		var pivot2 = new THREE.Object3D();
		pivot2.add(sphere2);
		pivot2.add(light2);
		scene.add(pivot2);
		pivot2.position.set(0, 15, 0);


		//ice cream
		//brown sphere
		/*
		var iceCreamGeometry = new THREE.SphereGeometry(5.8, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
		const iceCreamMaterial = new THREE.MeshPhongMaterial( { color: 0x4b2d2a } );
		var iceCreamSphere = new THREE.Mesh(iceCreamGeometry, iceCreamMaterial);
		iceCreamSphere.position.set(0,10,0);
		scene.add(iceCreamSphere);
*/
		var iceCreamGeometry = new THREE.SphereGeometry(5.8, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
		const iceCreamMaterial = new THREE.MeshPhongMaterial({ color: 0x4b2d2a });
		var iceCreamSphere = new THREE.Mesh(iceCreamGeometry, iceCreamMaterial);
		iceCreamSphere.position.set(0, 10, 0);
		scene.add(iceCreamSphere);

		renderer.domElement.addEventListener('mousemove', onDocumentMouseMove);

		function onDocumentMouseMove(event) {
			event.preventDefault();

			const mouse = new THREE.Vector2();
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

			iceCreamSphere.scale.set(1, 1, 1);

			const raycaster = new THREE.Raycaster();
			raycaster.setFromCamera(mouse, camera);

			const intersects = raycaster.intersectObjects(scene.children);

			if (intersects.length > 0) {
				if (intersects[0].object === iceCreamSphere) {
					var targetScale = new THREE.Vector3(4, 4, 4);
					var currentScale = iceCreamSphere.scale.clone();
					var scaleIncrement = new THREE.Vector3().subVectors(targetScale, currentScale).multiplyScalar(0.05);

					function increaseScale() {
						currentScale.add(scaleIncrement);
						iceCreamSphere.scale.copy(currentScale);

						if (currentScale.x < targetScale.x || currentScale.y < targetScale.y || currentScale.z < targetScale.z) {
							setTimeout(increaseScale, 10);
						}
					}

					setTimeout(increaseScale, 10);
				}
			} else {
				iceCreamSphere.scale.set(1, 1, 1);
			}
		}









/*
var originalY = iceCreamSphere.position.y;

// Add a mouseover event listener to the sphere
iceCreamSphere.addEventListener('mouseover', function() {
  // When the mouse is over the sphere, translate it by 10 units in the y direction
  iceCreamSphere.position.setY(originalY + 10);
});

// Add a mouseout event listener to the sphere
iceCreamSphere.addEventListener('mouseout', function() {
  // When the mouse is no longer over the sphere, reset its position to its original y position
  iceCreamSphere.position.setY(originalY);
});

scene.add(iceCreamSphere);




		const originalScale = iceCreamSphere.scale.clone();

// Set the userData property to make the sphere interactive
iceCreamSphere.userData = { interactive: true };

// Add a mouseover event listener to the sphere
iceCreamSphere.addEventListener('mouseover', () => {
  // Scale up the sphere by a factor of 1.2
  iceCreamSphere.scale.multiplyScalar(1.2);
});

// Add a mouseout event listener to the sphere
iceCreamSphere.addEventListener('mouseout', () => {
  // Reset the scale of the sphere to its original value
  iceCreamSphere.scale.copy(originalScale);
});

*/
/*
scene.add(iceCreamSphere);

renderer.domElement.addEventListener('mousemove', onMouseMove);

function onMouseMove(event) {
  // calculate mouse position in normalized device coordinates
  // (-1 to +1) for both components
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

  // perform raycasting from the camera through the mouse position
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);

  // get the list of objects intersected by the raycaster
  const intersects = raycaster.intersectObjects(scene.children, true);

  // check if the intersected object is the ice cream sphere
  if (intersects.length > 0 && intersects[0].object === iceCreamSphere) {
    iceCreamSphere.scale.multiplyScalar(1.2);
  } else {
    iceCreamSphere.scale.copy(originalScale);
  }
}
*/
		//pink torus
		const iceCreamTorusGeometry = new THREE.TorusGeometry(5, 1.4, 16, 100);
		const iceCreamTorus2 = new THREE.Mesh(iceCreamTorusGeometry, iceCreamMaterial);
	    scene.add(iceCreamTorus2);
	    iceCreamTorus2.rotation.x = Math.PI / 2;
	    iceCreamTorus2.position.set(0, 8, 0);

	    //white sphere
		const iceCreamMaterial2 = new THREE.MeshPhongMaterial( { color: 0xf6b3dc } );
		var iceCreamSphere2 = new THREE.Mesh(iceCreamGeometry, iceCreamMaterial2);
		iceCreamSphere2.position.set(0,16,0);
		scene.add(iceCreamSphere2);
		
		//white torus
	    const iceCreamTorus = new THREE.Mesh(iceCreamTorusGeometry, iceCreamMaterial2);
	    scene.add(iceCreamTorus);
	    iceCreamTorus.rotation.x = Math.PI / 2;
	    iceCreamTorus.position.set(0, 14, 0);

	    //bottom cone
	    const iceCreamConeGeometry = new THREE.CylinderGeometry( 5, 3.5, 10, 32 );
		const iceCreamConeMaterial = new THREE.MeshPhongMaterial( {color: 0xC4AE78} );
		const iceCreamCylinder = new THREE.Mesh(iceCreamConeGeometry, iceCreamConeMaterial);
		scene.add(iceCreamCylinder);

		//top cone
		const iceCreamConeGeometry2 = new THREE.CylinderGeometry( 6, 5.3, 5, 32 );
		const iceCreamCylinder2 = new THREE.Mesh(iceCreamConeGeometry2 , iceCreamConeMaterial);
	    scene.add(iceCreamCylinder2);
	    iceCreamCylinder2.position.set(0, 5, 0);

	    //bottom cone mesh
	    const iceCreamConeGeometry3 = new THREE.CylinderGeometry(6, 4.5, 8, 16);
	    const iceCreamConeMaterial2 = new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true, opacity: 0.2, transparent: true});
	    const iceCreamConeMesh = new THREE.Mesh(iceCreamConeGeometry3, iceCreamConeMaterial2);
	    scene.add(iceCreamConeMesh);
	    iceCreamConeMesh.position.set(0,-2,0);

	    //top cone mesh
	    const iceCreamConeGeometry4 = new THREE.CylinderGeometry(7, 6.3, 5, 16);
	    const iceCreamConeMesh2 = new THREE.Mesh(iceCreamConeGeometry4, iceCreamConeMaterial2);
	    scene.add(iceCreamConeMesh2);
	    iceCreamConeMesh2.position.set(0,4.5,0);

	    //stars
	    const starsGroup = new THREE.Group();
	    const stars = [];

	    for (let i = 0; i < 100; i++) {
			const starGeometry = new THREE.SphereGeometry(1, 32, 32);
			const starMaterial = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });


			const star = new THREE.Mesh(starGeometry, starMaterial);
		  	const x = Math.random() * 800-400; // Random x coordinate between -50 and 50
		  	const y = Math.random() * 400; // Random y coordinate between -50 and 50
		  	const z = Math.random() * 800-400; // Random z coordinate between -50 and 50
		  	//if ((x > -100 && x < 100)) continue;
		  	const x1 = Math.pow(x, 2);
		  	const y1 = Math.pow(y, 2);
		  	const z1 = Math.pow(z, 2);

		  	const squareSum = x1 + y1 + z1;

		  	if ((Math.sqrt(squareSum) < 200)  ) continue;

		  	star.position.set(x, y, z);
		  	starsGroup.add(star);
		  	//stars.push(star);
		  	//scene.add(star);
		}

		
		//starsGroup.add(stars);
		scene.add(starsGroup);

		var pivot3 = new THREE.Object3D();
		pivot3.add(starsGroup);
		scene.add(pivot3);
		pivot3.position.set(0, 0, 0);

	    

	    //animatiion
	    function animate() {
	    	requestAnimationFrame(animate);

	    	/*
		    torus.rotation.x += 0.01;
		    torus.rotation.y += 0.02;
		    torus.rotation.z += 0.00;
		    

		    torusKnot.rotation.x += 0.01;
		    torusKnot.rotation.y += 0.01;
		    torusKnot.rotation.z += 0.01;

		    */


		    //sphere.rotation.y += 0.01;
		    /*
		    pivot.rotation.y += 0.01;
		    pivot.rotation.z += 0.01;
		    */
		    pivot.rotation.y += 0.01;
		    pivot2.rotation.y -= 0.01;
		    pivot3.rotation.y += 0.002;
		   
		    iceCreamConeMesh.rotation.y += 0.005;
		    iceCreamConeMesh2.rotation.y -= 0.005;


		    //stars[1].rotation.y += 0.01;
		    //starsGroup.rotation.x +=0.05;





		    var time = Date.now() * 0.001;
		    //material.color.setHSL( (Math.sin(time) + 0.2) / 2, 3, 0.5 );
		    controls.update();

		    renderer.render(scene, camera);

		}
		function render() {
  			requestAnimationFrame(render);
  			renderer.render(scene, camera);
		}

		
	    animate();
	    render();

	    //window.addEventListener('mousemove', onMouseMove);

  	</script>


</body>
</html>